package main

import (
  "fmt"
  "strconv"
  "net/http"
  "os"
  "log"
  "os/exec"

  "github.com/gin-gonic/gin"
  "github.com/gorilla/websocket"
)


var upgrader = websocket.Upgrader{
  ReadBufferSize:  1024,
  WriteBufferSize: 1024,
}

func main() {
  if len(os.Args) < 2 {
    log.Fatal("Insufficient cli args\n\tUsages: go run server.go [offset]\n\t\tThis will run server at port: offset+3000")
  }
  val, err := strconv.Atoi(os.Args[1])
  if err != nil {
    log.Fatal("Second Arg must be a number")
  }

  router := gin.Default()
  router.MaxMultipartMemory = 8 << 20 // 8 MiB
  router.GET("/ws",
    func (c *gin.Context) {
      conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
      if err != nil {
        c.JSON(http.StatusInternalServerError, err.Error())
        return
      }
      defer conn.Close()

      for {
        messageType, message, err := conn.ReadMessage()
        if err != nil {
          if websocket.IsCloseError(err, websocket.CloseNormalClosure) {
            fmt.Println("Connection closed cleanly")
            return
          }
          fmt.Println("Error reading message: ", err)
          break
        }
        switch (messageType){
        case websocket.PingMessage:
          _ = conn.WriteMessage(websocket.PongMessage, message)
          continue
        case websocket.TextMessage:
          cmdstr := string(message)
          if cmdstr != "temperature" {
            fmt.Println("Exec: "+ cmdstr)
          }
          cmd := exec.Command("bash", "-c", "cat /tmp/ramfss/"+ cmdstr)
          str, err := cmd.Output()
          if err != nil {
            conn.WriteMessage(websocket.TextMessage, []byte("Error: "+ string(err.Error())) )
            continue
          }
          conn.WriteMessage(websocket.TextMessage, str)
          continue
        };
      }
    },
  );
  router.StaticFile("/", "./dist/index.html")
  router.Static("/js", "./dist/js")
  router.Static("/css", "./dist/css")

  router.Run(":"+ strconv.Itoa(3000+val))
}
